/* This file is generated by scripts/generate-ts-sdk.py. */
/* Do not edit by hand. */

import { ActivateConfigRequest, ActivateConfigResponse, Chunk, CocoErrorKind, ErrorResponse, HealthResponse, HnswParams, IndexRequest, IndexResponse, IndexingConfigResponse, IngestBatchRequest, IngestBatchResponse, IngestChunk, IngestDocument, IvfPqParams, JobStatusResponse, ListConfigsQuery, ListConfigsResponse, MemoQueryRequest, MemoQueryResponseEnvelope, PruneRequest, PruneResponse, PublicFilter, PublicFilterOp, PublicSearchIntent, QueryRequest, QueryResponse, QueryResponseEnvelope, QueueStatusResponse, RegisterProjectRequest, RegisterProjectResponse, RerankerConfig, ResponseMeta, ResponseStatus, RetrievalMode, SearchHit, SearchHitMeta, TextSpan, UpsertConfigRequest, VectorBackendKind, VectorBackendStatus, VectorIndexParams, VectorMetric, WorkerStatusResponse } from "./types";

export interface CocoClientConfig {
  baseUrl: string;
  apiKey?: string;
}

export interface IndexDocumentsHeaders {
  "x-coco-org-id": string;
  "x-coco-project-id": string;
}
export interface QueryDocumentsHeaders {
  "x-coco-org-id": string;
  "x-coco-project-id": string;
}
export interface IngestBatchHeaders {
  "x-coco-org-id": string;
  "x-coco-project-id": string;
}

export interface ListConfigsQuery {
  "org_id": string;
  "project_id"?: string | null;
}

export class CocoClient {
  private readonly baseUrl: string;
  private readonly apiKey?: string;

  constructor(config: CocoClientConfig) {
    this.baseUrl = config.baseUrl.endsWith('/') ? config.baseUrl : `${config.baseUrl}/`;
    this.apiKey = config.apiKey;
  }

  private withAuth(init: RequestInit): RequestInit {
    if (!this.apiKey) {
      return init;
    }
    const headers = new Headers(init.headers ?? {});
    headers.set('authorization', `Bearer ${this.apiKey}`);
    return { ...init, headers };
  }

  async indexDocuments(request: IndexRequest, headers: IndexDocumentsHeaders): Promise<IndexResponse> {
    const url = new URL(`/v1/docs/index`, this.baseUrl);
    const body = JSON.stringify(request);
    const merged = { ...headers };
    merged["content-type"] = "application/json";
    const response = await fetch(url.toString(), this.withAuth({ method: "POST", headers: merged, body }));
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Request failed: ${response.status} ${text}`);
    }
    return (await response.json()) as IndexResponse;
  }
  async queryDocuments(request: QueryRequest, headers: QueryDocumentsHeaders): Promise<QueryResponseEnvelope> {
    const url = new URL(`/v1/docs/query`, this.baseUrl);
    const body = JSON.stringify(request);
    const merged = { ...headers };
    merged["content-type"] = "application/json";
    const response = await fetch(url.toString(), this.withAuth({ method: "POST", headers: merged, body }));
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Request failed: ${response.status} ${text}`);
    }
    return (await response.json()) as QueryResponseEnvelope;
  }
  async ingestBatch(request: IngestBatchRequest, headers: IngestBatchHeaders): Promise<IngestBatchResponse> {
    const url = new URL(`/v1/ingest/batch`, this.baseUrl);
    const body = JSON.stringify(request);
    const merged = { ...headers };
    merged["content-type"] = "application/json";
    const response = await fetch(url.toString(), this.withAuth({ method: "POST", headers: merged, body }));
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Request failed: ${response.status} ${text}`);
    }
    return (await response.json()) as IngestBatchResponse;
  }
  async getJob(id: string): Promise<JobStatusResponse> {
    const url = new URL(`/v1/jobs/${id}`, this.baseUrl);
    const merged: Record<string, string> = {};
    const response = await fetch(url.toString(), this.withAuth({ method: "GET", headers: merged }));
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Request failed: ${response.status} ${text}`);
    }
    return (await response.json()) as JobStatusResponse;
  }
  async jobEvents(id: string): Promise<Response> {
    const url = new URL(`/v1/jobs/${id}/events`, this.baseUrl);
    const merged: Record<string, string> = {};
    const response = await fetch(url.toString(), this.withAuth({ method: "GET", headers: merged }));
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Request failed: ${response.status} ${text}`);
    }
    return response;
  }
  async queryMemos(request: MemoQueryRequest): Promise<MemoQueryResponseEnvelope> {
    const url = new URL(`/v1/memo/query`, this.baseUrl);
    const body = JSON.stringify(request);
    const merged: Record<string, string> = {};
    merged["content-type"] = "application/json";
    const response = await fetch(url.toString(), this.withAuth({ method: "POST", headers: merged, body }));
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Request failed: ${response.status} ${text}`);
    }
    return (await response.json()) as MemoQueryResponseEnvelope;
  }
  async listConfigs(query: ListConfigsQuery): Promise<ListConfigsResponse> {
    const url = new URL(`/v1/sys/configs`, this.baseUrl);
    if (query) {
      const entries = query as Record<string, unknown>;
      for (const [key, value] of Object.entries(entries)) {
        if (value !== undefined && value !== null) {
          url.searchParams.set(key, String(value));
        }
      }
    }
    const merged: Record<string, string> = {};
    const response = await fetch(url.toString(), this.withAuth({ method: "GET", headers: merged }));
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Request failed: ${response.status} ${text}`);
    }
    return (await response.json()) as ListConfigsResponse;
  }
  async upsertConfig(request: UpsertConfigRequest): Promise<IndexingConfigResponse> {
    const url = new URL(`/v1/sys/configs`, this.baseUrl);
    const body = JSON.stringify(request);
    const merged: Record<string, string> = {};
    merged["content-type"] = "application/json";
    const response = await fetch(url.toString(), this.withAuth({ method: "POST", headers: merged, body }));
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Request failed: ${response.status} ${text}`);
    }
    return (await response.json()) as IndexingConfigResponse;
  }
  async activateConfig(request: ActivateConfigRequest): Promise<ActivateConfigResponse> {
    const url = new URL(`/v1/sys/configs/activate`, this.baseUrl);
    const body = JSON.stringify(request);
    const merged: Record<string, string> = {};
    merged["content-type"] = "application/json";
    const response = await fetch(url.toString(), this.withAuth({ method: "POST", headers: merged, body }));
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Request failed: ${response.status} ${text}`);
    }
    return (await response.json()) as ActivateConfigResponse;
  }
  async health(): Promise<HealthResponse> {
    const url = new URL(`/v1/sys/health`, this.baseUrl);
    const merged: Record<string, string> = {};
    const response = await fetch(url.toString(), this.withAuth({ method: "GET", headers: merged }));
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Request failed: ${response.status} ${text}`);
    }
    return (await response.json()) as HealthResponse;
  }
  async pruneProject(request: PruneRequest): Promise<PruneResponse> {
    const url = new URL(`/v1/sys/prune`, this.baseUrl);
    const body = JSON.stringify(request);
    const merged: Record<string, string> = {};
    merged["content-type"] = "application/json";
    const response = await fetch(url.toString(), this.withAuth({ method: "POST", headers: merged, body }));
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Request failed: ${response.status} ${text}`);
    }
    return (await response.json()) as PruneResponse;
  }
  async registerProject(request: RegisterProjectRequest): Promise<RegisterProjectResponse> {
    const url = new URL(`/v1/sys/register`, this.baseUrl);
    const body = JSON.stringify(request);
    const merged: Record<string, string> = {};
    merged["content-type"] = "application/json";
    const response = await fetch(url.toString(), this.withAuth({ method: "POST", headers: merged, body }));
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Request failed: ${response.status} ${text}`);
    }
    return (await response.json()) as RegisterProjectResponse;
  }
}
