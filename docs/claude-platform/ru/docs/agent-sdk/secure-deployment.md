# Безопасное развертывание AI-агентов

Руководство по защите развертываний Claude Code и Agent SDK с использованием изоляции, управления учетными данными и сетевых элементов управления

---

Claude Code и Agent SDK — это мощные инструменты, которые могут выполнять код, получать доступ к файлам и взаимодействовать с внешними сервисами от вашего имени. Как и любой инструмент с такими возможностями, их продуманное развертывание гарантирует, что вы получите преимущества, сохраняя при этом надлежащий контроль.

В отличие от традиционного программного обеспечения, которое следует предопределенным путям кода, эти инструменты динамически генерируют свои действия на основе контекста и целей. Эта гибкость делает их полезными, но это также означает, что их поведение может быть подвержено влиянию содержимого, которое они обрабатывают: файлы, веб-страницы или пользовательский ввод. Это иногда называют инъекцией подсказок. Например, если README репозитория содержит необычные инструкции, Claude Code может включить их в свои действия способами, которые оператор не предусмотрел. Это руководство охватывает практические способы снижения этого риска.

Хорошая новость заключается в том, что защита развертывания агента не требует экзотической инфраструктуры. Те же принципы, которые применяются к запуску любого полудоверенного кода, применяются здесь: изоляция, принцип наименьших привилегий и защита в глубину. Claude Code включает несколько функций безопасности, которые помогают с общими проблемами, и это руководство проходит через них вместе с дополнительными вариантами усиления для тех, кому они нужны.

Не каждое развертывание требует максимальной безопасности. Разработчик, запускающий Claude Code на своем ноутбуке, имеет другие требования, чем компания, обрабатывающая данные клиентов в многотенантной среде. Это руководство представляет варианты, начиная от встроенных функций безопасности Claude Code до усиленных архитектур производства, поэтому вы можете выбрать то, что подходит вашей ситуации.

## Что мы защищаем?

Агенты могут предпринимать непредусмотренные действия из-за инъекции подсказок (инструкции, встроенные в содержимое, которое они обрабатывают) или ошибки модели. Модели Claude разработаны для сопротивления этому, и, как мы проанализировали в нашей [карточке модели](https://assets.anthropic.com/m/64823ba7485345a7/Claude-Opus-4-5-System-Card.pdf), мы считаем, что Claude Opus 4.5 — это самая надежная граничная модель из доступных.

Защита в глубину — это все еще хорошая практика. Например, если агент обрабатывает вредоносный файл, который инструктирует его отправить данные клиента на внешний сервер, сетевые элементы управления могут полностью заблокировать этот запрос.

## Встроенные функции безопасности

Claude Code включает несколько функций безопасности, которые решают общие проблемы. Полные детали см. в [документации по безопасности](https://code.claude.com/docs/en/security).

- **Система разрешений**: Каждый инструмент и команда bash можно настроить на разрешение, блокировку или запрос одобрения у пользователя. Используйте глобальные шаблоны для создания правил, таких как «разрешить все команды npm» или «заблокировать любую команду с sudo». Организации могут устанавливать политики, которые применяются ко всем пользователям. См. [управление доступом и разрешения](https://code.claude.com/docs/en/iam#access-control-and-permissions).
- **Статический анализ**: Перед выполнением команд bash Claude Code запускает статический анализ для выявления потенциально рискованных операций. Команды, которые изменяют системные файлы или получают доступ к конфиденциальным каталогам, помечаются и требуют явного одобрения пользователя.
- **Суммирование веб-поиска**: Результаты поиска суммируются, а не передаются в контекст в виде необработанного содержимого, что снижает риск инъекции подсказок из вредоносного веб-содержимого.
- **Режим песочницы**: Команды bash могут работать в изолированной среде, которая ограничивает доступ к файловой системе и сети. Подробности см. в [документации по изоляции](https://code.claude.com/docs/en/sandboxing).

## Принципы безопасности

Для развертываний, требующих дополнительного усиления сверх значений по умолчанию Claude Code, эти принципы направляют доступные варианты.

### Границы безопасности

Граница безопасности отделяет компоненты с разными уровнями доверия. Для развертываний с высокой безопасностью вы можете разместить конфиденциальные ресурсы (такие как учетные данные) вне границы, содержащей агента. Если что-то пойдет не так в среде агента, ресурсы вне этой границы остаются защищенными.

Например, вместо того чтобы давать агенту прямой доступ к ключу API, вы можете запустить прокси вне среды агента, который вводит ключ в запросы. Агент может делать вызовы API, но он никогда не видит саму учетную данные. Этот паттерн полезен для многотенантных развертываний или при обработке ненадежного содержимого.

### Принцип наименьших привилегий

При необходимости вы можете ограничить агента только возможностями, необходимыми для его конкретной задачи:

| Ресурс | Варианты ограничения |
|----------|---------------------|
| Файловая система | Монтируйте только необходимые каталоги, предпочитайте только для чтения |
| Сеть | Ограничьте конкретными конечными точками через прокси |
| Учетные данные | Вводите через прокси, а не раскрывайте напрямую |
| Возможности системы | Удалите возможности Linux в контейнерах |

### Защита в глубину

Для высокозащищенных сред наслоение нескольких элементов управления обеспечивает дополнительную защиту. Варианты включают:

- Изоляция контейнера
- Ограничения сети
- Элементы управления файловой системой
- Проверка запроса на прокси

Правильная комбинация зависит от вашей модели угроз и операционных требований.

## Технологии изоляции

Различные технологии изоляции предлагают различные компромиссы между силой безопасности, производительностью и операционной сложностью.

<Info>
Во всех этих конфигурациях Claude Code (или ваше приложение Agent SDK) работает внутри границы изоляции — песочницы, контейнера или виртуальной машины. Описанные ниже элементы управления безопасностью ограничивают, к чему агент может получить доступ из этой границы.
</Info>

| Технология | Сила изоляции | Накладные расходы производительности | Сложность |
|------------|-------------------|---------------------|------------|
| Среда выполнения песочницы | Хорошо (безопасные значения по умолчанию) | Очень низко | Низко |
| Контейнеры (Docker) | Зависит от настройки | Низко | Среднее |
| gVisor | Отлично (при правильной настройке) | Среднее/Высокое | Среднее |
| Виртуальные машины (Firecracker, QEMU) | Отлично (при правильной настройке) | Высокое | Среднее/Высокое |

### Среда выполнения песочницы

Для легкой изоляции без контейнеров [sandbox-runtime](https://github.com/anthropic-experimental/sandbox-runtime) обеспечивает ограничения файловой системы и сети на уровне ОС.

Основное преимущество — простота: не требуется конфигурация Docker, образы контейнеров или настройка сети. Прокси и ограничения файловой системы встроены. Вы предоставляете файл настроек, указывающий разрешенные домены и пути.

**Как это работает:**
- **Файловая система**: Использует примитивы ОС (`bubblewrap` на Linux, `sandbox-exec` на macOS) для ограничения доступа на чтение/запись к настроенным путям
- **Сеть**: Удаляет пространство имен сети (Linux) или использует профили Seatbelt (macOS) для маршрутизации сетевого трафика через встроенный прокси
- **Конфигурация**: Списки разрешений на основе JSON для доменов и путей файловой системы

**Установка:**
```bash
npm install @anthropic-ai/sandbox-runtime
```

Затем создайте файл конфигурации, указывающий разрешенные пути и домены.

**Соображения безопасности:**

1. **Ядро на одном хосте**: В отличие от виртуальных машин, изолированные процессы используют ядро хоста совместно. Уязвимость ядра теоретически может позволить выход. Для некоторых моделей угроз это приемлемо, но если вам нужна изоляция на уровне ядра, используйте gVisor или отдельную виртуальную машину.

2. **Нет проверки TLS**: Прокси использует списки разрешений доменов, но не проверяет зашифрованный трафик. Если агент имеет разрешительные учетные данные для разрешенного домена, убедитесь, что невозможно использовать этот домен для запуска других сетевых запросов или для утечки данных.

Для многих случаев использования одного разработчика и CI/CD sandbox-runtime значительно повышает планку с минимальной настройкой. Разделы ниже охватывают контейнеры и виртуальные машины для развертываний, требующих более сильной изоляции.

### Контейнеры

Контейнеры обеспечивают изоляцию через пространства имен Linux. Каждый контейнер имеет свой собственный вид файловой системы, дерева процессов и стека сети, при этом совместно используя ядро хоста.

Конфигурация контейнера с усиленной безопасностью может выглядеть так:

```bash
docker run \
  --cap-drop ALL \
  --security-opt no-new-privileges \
  --security-opt seccomp=/path/to/seccomp-profile.json \
  --read-only \
  --tmpfs /tmp:rw,noexec,nosuid,size=100m \
  --tmpfs /home/agent:rw,noexec,nosuid,size=500m \
  --network none \
  --memory 2g \
  --cpus 2 \
  --pids-limit 100 \
  --user 1000:1000 \
  -v /path/to/code:/workspace:ro \
  -v /var/run/proxy.sock:/var/run/proxy.sock:ro \
  agent-image
```

Вот что делает каждый вариант:

| Вариант | Назначение |
|--------|---------|
| `--cap-drop ALL` | Удаляет возможности Linux, такие как `NET_ADMIN` и `SYS_ADMIN`, которые могут позволить повышение привилегий |
| `--security-opt no-new-privileges` | Предотвращает получение процессами привилегий через двоичные файлы setuid |
| `--security-opt seccomp=...` | Ограничивает доступные системные вызовы; значение по умолчанию Docker блокирует ~44, пользовательские профили могут блокировать больше |
| `--read-only` | Делает корневую файловую систему контейнера неизменяемой, предотвращая сохранение изменений агентом |
| `--tmpfs /tmp:...` | Предоставляет записываемый временный каталог, который очищается при остановке контейнера |
| `--network none` | Удаляет все сетевые интерфейсы; агент взаимодействует через смонтированный сокет Unix ниже |
| `--memory 2g` | Ограничивает использование памяти, чтобы предотвратить истощение ресурсов |
| `--pids-limit 100` | Ограничивает количество процессов, чтобы предотвратить fork-бомбы |
| `--user 1000:1000` | Работает как непривилегированный пользователь |
| `-v ...:/workspace:ro` | Монтирует код только для чтения, чтобы агент мог анализировать, но не изменять его. **Избегайте монтирования конфиденциальных каталогов хоста, таких как `~/.ssh`, `~/.aws` или `~/.config`** |
| `-v .../proxy.sock:...` | Монтирует сокет Unix, подключенный к прокси, работающему вне контейнера (см. ниже) |

**Архитектура сокета Unix:**

С `--network none` контейнер вообще не имеет сетевых интерфейсов. Единственный способ для агента достичь внешнего мира — через смонтированный сокет Unix, который подключается к прокси, работающему на хосте. Этот прокси может обеспечивать списки разрешений доменов, вводить учетные данные и регистрировать весь трафик.

Это та же архитектура, используемая [sandbox-runtime](https://github.com/anthropic-experimental/sandbox-runtime). Даже если агент скомпрометирован через инъекцию подсказок, он не может утечь данные на произвольные серверы — он может взаимодействовать только через прокси, который контролирует, какие домены доступны. Для получения дополнительной информации см. [блог Claude Code sandboxing](https://www.anthropic.com/engineering/claude-code-sandboxing).

**Дополнительные варианты усиления:**

| Вариант | Назначение |
|--------|---------|
| `--userns-remap` | Отображает корень контейнера на непривилегированного пользователя хоста; требует конфигурации демона, но ограничивает ущерб от выхода контейнера |
| `--ipc private` | Изолирует межпроцессное взаимодействие, чтобы предотвратить атаки между контейнерами |

### gVisor

Стандартные контейнеры используют ядро хоста совместно: когда код внутри контейнера делает системный вызов, он идет прямо к тому же ядру, которое запускает хост. Это означает, что уязвимость ядра может позволить выход контейнера. gVisor решает эту проблему, перехватывая системные вызовы в пользовательском пространстве перед тем, как они достигнут ядра хоста, реализуя свой собственный уровень совместимости, который обрабатывает большинство системных вызовов без участия реального ядра.

Если агент запускает вредоносный код (возможно, из-за инъекции подсказок), этот код работает в контейнере и может попытаться использовать уязвимости ядра. С gVisor поверхность атаки намного меньше: вредоносный код должен сначала использовать реализацию gVisor в пользовательском пространстве и будет иметь ограниченный доступ к реальному ядру.

Чтобы использовать gVisor с Docker, установите среду выполнения `runsc` и настройте демон:

```json
// /etc/docker/daemon.json
{
  "runtimes": {
    "runsc": {
      "path": "/usr/local/bin/runsc"
    }
  }
}
```

Затем запустите контейнеры с:

```bash
docker run --runtime=runsc agent-image
```

**Соображения производительности:**

| Рабочая нагрузка | Накладные расходы |
|----------|----------|
| Вычисления, связанные с ЦП | ~0% (нет перехвата системных вызовов) |
| Простые системные вызовы | ~2× медленнее |
| Интенсивный ввод-вывод файлов | До 10-200× медленнее для тяжелых паттернов открытия/закрытия |

Для многотенантных сред или при обработке ненадежного содержимого дополнительная изоляция часто стоит накладных расходов.

### Виртуальные машины

Виртуальные машины обеспечивают изоляцию на уровне оборудования через расширения виртуализации ЦП. Каждая виртуальная машина запускает свое собственное ядро, создавая сильную границу — уязвимость в ядре гостя не напрямую компрометирует хост. Однако виртуальные машины не являются автоматически «более безопасными», чем альтернативы, такие как gVisor. Безопасность виртуальной машины сильно зависит от гипервизора и кода эмуляции устройства.

Firecracker разработан для легкой изоляции microVM — он может загружать виртуальные машины менее чем за 125 мс с накладными расходами памяти менее 5 МиБ, удаляя ненужную эмуляцию устройств, чтобы уменьшить поверхность атаки.

При таком подходе виртуальная машина агента не имеет внешнего сетевого интерфейса. Вместо этого она взаимодействует через `vsock` (виртуальные сокеты). Весь трафик маршрутизируется через vsock к прокси на хосте, который обеспечивает списки разрешений и вводит учетные данные перед пересылкой запросов.

### Облачные развертывания

Для облачных развертываний вы можете комбинировать любую из вышеуказанных технологий изоляции с облачными сетевыми элементами управления:

1. Запустите контейнеры агента в приватной подсети без интернет-шлюза
2. Настройте правила облачного брандмауэра (AWS Security Groups, GCP VPC firewall) для блокировки всего исходящего трафика, кроме вашего прокси
3. Запустите прокси (такой как [Envoy](https://www.envoyproxy.io/) с его фильтром `credential_injector`), который проверяет запросы, обеспечивает списки разрешений доменов, вводит учетные данные и пересылает на внешние API
4. Назначьте минимальные разрешения IAM учетной записи сервиса агента, маршрутизируя конфиденциальный доступ через прокси, где это возможно
5. Регистрируйте весь трафик на прокси в целях аудита

## Управление учетными данными

Агентам часто нужны учетные данные для вызова API, доступа к репозиториям или взаимодействия с облачными сервисами. Задача состоит в том, чтобы предоставить этот доступ без раскрытия самих учетных данных.

### Паттерн прокси

Рекомендуемый подход — запустить прокси вне границы безопасности агента, который вводит учетные данные в исходящие запросы. Агент отправляет запросы без учетных данных, прокси добавляет их и пересылает запрос на его назначение.

Этот паттерн имеет несколько преимуществ:

1. Агент никогда не видит фактические учетные данные
2. Прокси может обеспечивать список разрешений разрешенных конечных точек
3. Прокси может регистрировать все запросы для аудита
4. Учетные данные хранятся в одном безопасном месте, а не распределяются каждому агенту

### Настройка Claude Code для использования прокси

Claude Code поддерживает два метода маршрутизации запросов выборки через прокси:

**Вариант 1: ANTHROPIC_BASE_URL (простой, но только для запросов API выборки)**

```bash
export ANTHROPIC_BASE_URL="http://localhost:8080"
```

Это говорит Claude Code и Agent SDK отправлять запросы выборки на ваш прокси вместо прямого обращения к API Anthropic. Ваш прокси получает открытые HTTP-запросы, может проверять и изменять их (включая введение учетных данных), затем пересылает на реальный API.

**Вариант 2: HTTP_PROXY / HTTPS_PROXY (системный)**

```bash
export HTTP_PROXY="http://localhost:8080"
export HTTPS_PROXY="http://localhost:8080"
```

Claude Code и Agent SDK соблюдают эти стандартные переменные окружения, маршрутизируя весь HTTP-трафик через прокси. Для HTTPS прокси создает зашифрованный туннель CONNECT: он не может видеть или изменять содержимое запроса без перехвата TLS.

### Реализация прокси

Вы можете создать свой собственный прокси или использовать существующий:

- [Envoy Proxy](https://www.envoyproxy.io/) — прокси производственного уровня с фильтром `credential_injector` для добавления заголовков аутентификации
- [mitmproxy](https://mitmproxy.org/) — прокси с завершением TLS для проверки и изменения трафика HTTPS
- [Squid](http://www.squid-cache.org/) — кэширующий прокси со списками управления доступом
- [LiteLLM](https://github.com/BerriAI/litellm) — шлюз LLM с введением учетных данных и ограничением скорости

### Учетные данные для других сервисов

Помимо выборки из API Anthropic, агентам часто нужен аутентифицированный доступ к другим сервисам — репозиториям git, базам данных, внутренним API. Есть два основных подхода:

#### Пользовательские инструменты

Предоставьте доступ через сервер MCP или пользовательский инструмент, который маршрутизирует запросы к сервису, работающему вне границы безопасности агента. Агент вызывает инструмент, но фактический аутентифицированный запрос происходит снаружи — инструмент вызывает прокси, который вводит учетные данные перед контактом с удаленным репозиторием. Агент никогда не видит учетные данные.

Преимущества:
- **Нет перехвата TLS**: Внешний сервис делает аутентифицированные запросы напрямую
- **Учетные данные остаются снаружи**: Агент видит только интерфейс инструмента, не лежащие в основе учетные данные

#### Пересылка трафика

Для вызовов API Anthropic `ANTHROPIC_BASE_URL` позволяет маршрутизировать запросы на прокси, который может проверять и изменять их в открытом виде. Но для других сервисов HTTPS (GitHub, реестры npm, внутренние API) трафик часто зашифрован от конца до конца — даже если вы маршрутизируете его через прокси через `HTTP_PROXY`, прокси видит только непрозрачный туннель TLS и не может вводить учетные данные.

Чтобы изменить трафик HTTPS на произвольные сервисы без использования пользовательского инструмента, вам нужен прокси с завершением TLS, который расшифровывает трафик, проверяет или изменяет его, затем повторно шифрует перед пересылкой. Это требует:

1. Запуска прокси вне контейнера агента
2. Установки сертификата ЦС прокси в хранилище доверия агента (чтобы агент доверял сертификатам прокси)
3. Настройки `HTTP_PROXY`/`HTTPS_PROXY` для маршрутизации трафика через прокси

Этот подход обрабатывает любой сервис на основе HTTP без написания пользовательских инструментов, но добавляет сложность вокруг управления сертификатами.

Обратите внимание, что не все программы соблюдают `HTTP_PROXY`/`HTTPS_PROXY`. Большинство инструментов (curl, pip, npm, git) это делают, но некоторые могут обойти эти переменные и подключиться напрямую. Например, Node.js `fetch()` по умолчанию игнорирует эти переменные; в Node 24+ вы можете установить `NODE_USE_ENV_PROXY=1` для включения поддержки. Для полного охвата вы можете использовать [proxychains](https://github.com/haad/proxychains) для перехвата сетевых вызовов или настроить iptables для перенаправления исходящего трафика на прозрачный прокси.

<Info>
**Прозрачный прокси** перехватывает трафик на сетевом уровне, поэтому клиент не нуждается в конфигурации для его использования. Обычные прокси требуют, чтобы клиенты явно подключались и говорили HTTP CONNECT или SOCKS. Прозрачные прокси (такие как Squid или mitmproxy в прозрачном режиме) могут обрабатывать необработанные перенаправленные TCP-соединения.
</Info>

Оба подхода все еще требуют прокси с завершением TLS и доверенного сертификата ЦС — они просто гарантируют, что трафик действительно достигает прокси.

## Конфигурация файловой системы

Элементы управления файловой системой определяют, какие файлы агент может читать и писать.

### Монтирование кода только для чтения

Когда агенту нужно анализировать код, но не изменять его, смонтируйте каталог только для чтения:

```bash
docker run -v /path/to/code:/workspace:ro agent-image
```

<Warning>
Даже доступ только для чтения к каталогу кода может раскрыть учетные данные. Общие файлы для исключения или очистки перед монтированием:

| Файл | Риск |
|------|------|
| `.env`, `.env.local` | Ключи API, пароли базы данных, секреты |
| `~/.git-credentials` | Пароли/токены Git в открытом виде |
| `~/.aws/credentials` | Ключи доступа AWS |
| `~/.config/gcloud/application_default_credentials.json` | Токены Google Cloud ADC |
| `~/.azure/` | Учетные данные Azure CLI |
| `~/.docker/config.json` | Токены аутентификации реестра Docker |
| `~/.kube/config` | Учетные данные кластера Kubernetes |
| `.npmrc`, `.pypirc` | Токены реестра пакетов |
| `*-service-account.json` | Ключи учетной записи сервиса GCP |
| `*.pem`, `*.key` | Приватные ключи |

Рассмотрите возможность копирования только необходимых исходных файлов или использования фильтрации в стиле `.dockerignore`.
</Warning>

### Записываемые местоположения

Если агенту нужно писать файлы, у вас есть несколько вариантов в зависимости от того, хотите ли вы, чтобы изменения сохранялись:

Для эфемерных рабочих пространств в контейнерах используйте монтирования `tmpfs`, которые существуют только в памяти и очищаются при остановке контейнера:

```bash
docker run \
  --read-only \
  --tmpfs /tmp:rw,noexec,nosuid,size=100m \
  --tmpfs /workspace:rw,noexec,size=500m \
  agent-image
```

Если вы хотите просмотреть изменения перед их сохранением, файловая система оверлея позволяет агенту писать без изменения базовых файлов — изменения хранятся в отдельном слое, который вы можете проверить, применить или отклонить. Для полностью постоянного вывода смонтируйте выделенный том, но держите его отдельно от конфиденциальных каталогов.

## Дополнительное чтение

- [Документация по безопасности Claude Code](https://code.claude.com/docs/en/security)
- [Размещение Agent SDK](/docs/ru/agent-sdk/hosting)
- [Обработка разрешений](/docs/ru/agent-sdk/permissions)
- [Sandbox runtime](https://github.com/anthropic-experimental/sandbox-runtime)
- [The Lethal Trifecta for AI Agents](https://simonwillison.net/2025/Jun/16/the-lethal-trifecta/)
- [OWASP Top 10 for LLM Applications](https://owasp.org/www-project-top-10-for-large-language-model-applications/)
- [Docker Security Best Practices](https://docs.docker.com/engine/security/)
- [gVisor Documentation](https://gvisor.dev/docs/)
- [Firecracker Documentation](https://firecracker-microvm.github.io/)