#!/usr/bin/env python3
import json
from pathlib import Path
from typing import Dict, List, Optional, Tuple


def ref_name(ref: str) -> str:
    return ref.rsplit("/", 1)[-1]


def schema_to_py(schema: Dict) -> str:
    if "$ref" in schema:
        return ref_name(schema["$ref"])
    if "allOf" in schema:
        parts = [schema_to_py(item) for item in schema["allOf"]]
        return parts[0] if parts else "Any"
    if "enum" in schema:
        literals = ", ".join(json.dumps(value) for value in schema["enum"])
        return f"Literal[{literals}]"
    schema_type = schema.get("type")
    if schema_type == "array":
        items = schema_to_py(schema.get("items", {}))
        return f"list[{items}]"
    if schema_type == "object" or "properties" in schema:
        return "dict[str, Any]"
    if schema_type == "string":
        return "str"
    if schema_type == "integer":
        return "int"
    if schema_type == "number":
        return "float"
    if schema_type == "boolean":
        return "bool"
    return "Any"


def render_typeddict(name: str, schema: Dict) -> str:
    props = schema.get("properties", {})
    required = set(schema.get("required", []))
    lines = [f"class {name}(TypedDict):"]
    if not props:
        lines.append("    pass")
        return "\n".join(lines)
    for prop_name in sorted(props.keys()):
        prop_schema = props[prop_name]
        py_type = schema_to_py(prop_schema)
        if prop_schema.get("nullable"):
            py_type = f"Optional[{py_type}]"
        if prop_name in required:
            lines.append(f"    {prop_name}: {py_type}")
        else:
            lines.append(f"    {prop_name}: NotRequired[{py_type}]")
    return "\n".join(lines)


def generate_types(openapi: Dict) -> str:
    schemas = openapi.get("components", {}).get("schemas", {})
    lines = [
        "# This file is generated by scripts/generate-py-sdk.py.",
        "# Do not edit by hand.",
        "",
        "from typing import Any, Literal, Optional, TypedDict",
        "",
        "try:",
        "    from typing import NotRequired",
        "except ImportError:  # pragma: no cover",
        "    class _NotRequired:",
        "        def __class_getitem__(cls, item):",
        "            return item",
        "    NotRequired = _NotRequired",
        "",
        "OpenApiDocument = dict[str, Any]",
        "",
    ]
    for name in sorted(schemas.keys()):
        schema = schemas[name]
        desc = schema.get("description")
        if desc:
            lines.append(f'"""{desc}"""')
        if "enum" in schema:
            lines.append(f"{name} = {schema_to_py(schema)}")
        elif schema.get("type") == "object" or "properties" in schema:
            lines.append(render_typeddict(name, schema))
        else:
            lines.append(f"{name} = {schema_to_py(schema)}")
        lines.append("")
    return "\n".join(lines).rstrip() + "\n"


def to_camel(name: str) -> str:
    parts = [p for p in name.replace("-", "_").split("_") if p]
    if not parts:
        return name
    return parts[0] + "".join(part.capitalize() for part in parts[1:])


def to_pascal(name: str) -> str:
    camel = to_camel(name)
    if not camel:
        return camel
    return camel[0].upper() + camel[1:]


def build_path(path: str, params: List[Dict]) -> Tuple[str, List[str]]:
    path_params = [p for p in params if p.get("in") == "path"]
    args = []
    rendered = path
    for param in path_params:
        name = param["name"]
        args.append(f"{name}: str")
        rendered = rendered.replace("{" + name + "}", f"{{{name}}}")
    return rendered, args


def header_params_type(op_id: str, params: List[Dict]) -> Tuple[str, Optional[str]]:
    header_params = [p for p in params if p.get("in") == "header"]
    if not header_params:
        return "", None
    type_name = f"{to_pascal(op_id)}Headers"
    entries = ", ".join(
        f"\"{param['name']}\": str" for param in header_params
    )
    return f"{type_name} = TypedDict(\"{type_name}\", {{{entries}}})", type_name


def query_params_type(
    op_id: str, params: List[Dict]
) -> Tuple[str, Optional[str], bool]:
    query_params = [p for p in params if p.get("in") == "query"]
    if not query_params:
        return "", None, False
    type_name = f"{to_pascal(op_id)}Query"
    lines = [f"class {type_name}(TypedDict):"]
    required_any = False
    for param in query_params:
        name = param["name"]
        required = param.get("required", False)
        required_any = required_any or required
        schema = param.get("schema", {})
        py_type = schema_to_py(schema)
        if schema.get("nullable"):
            py_type = f"Optional[{py_type}]"
        if required:
            lines.append(f"    {name}: {py_type}")
        else:
            lines.append(f"    {name}: NotRequired[{py_type}]")
    return "\n".join(lines), type_name, required_any


def response_type(op: Dict) -> Tuple[str, bool]:
    responses = op.get("responses", {})
    ok = responses.get("200", {})
    content = ok.get("content", {})
    if "application/json" in content:
        schema = content["application/json"].get("schema", {})
        return schema_to_py(schema), True
    return "bytes", False


def request_type(op: Dict) -> Optional[str]:
    body = op.get("requestBody", {})
    content = body.get("content", {})
    if "application/json" in content:
        schema = content["application/json"].get("schema", {})
        return schema_to_py(schema)
    return None


def generate_client(openapi: Dict) -> str:
    paths = openapi.get("paths", {})
    header_types: List[str] = []
    query_types: List[str] = []
    methods: List[str] = []
    for path, path_item in paths.items():
        for method, op in path_item.items():
            op_id = op.get("operationId") or f"{method}_{path}"
            params = op.get("parameters", [])
            rendered_path, path_args = build_path(path, params)
            header_decl, header_type = header_params_type(op_id, params)
            if header_decl:
                header_types.append(header_decl)
            query_decl, query_type, query_required = query_params_type(op_id, params)
            if query_decl:
                query_types.append(query_decl)
            req_type = request_type(op)
            res_type, json_response = response_type(op)
            func_name = to_camel(op_id)
            args = []
            args.extend(path_args)
            if query_type:
                if query_required:
                    args.append(f"query: {query_type}")
                else:
                    args.append(f"query: Optional[{query_type}] = None")
            if req_type:
                args.append(f"request: {req_type}")
            if header_type:
                args.append(f"headers: {header_type}")
            arg_list = ", ".join(["self"] + args)
            header_expr = "headers" if header_type else "None"
            body_expr = "request" if req_type else "None"
            query_expr = "query" if query_type else "None"
            response_expr = "True" if json_response else "False"
            method_lines = [
                f"    def {func_name}({arg_list}) -> {res_type}:",
                f"        return self._request(\"{method.upper()}\", f\"{rendered_path}\", {header_expr}, {body_expr}, {query_expr}, {response_expr})",
                "",
            ]
            methods.append("\n".join(method_lines))
    lines = [
        "# This file is generated by scripts/generate-py-sdk.py.",
        "# Do not edit by hand.",
        "",
        "import json",
        "from typing import Any, Optional",
        "from urllib import error, parse, request",
        "",
        "from .types import *",
        "",
    ]
    if header_types:
        lines.extend(header_types)
        lines.append("")
    if query_types:
        lines.extend(query_types)
        lines.append("")
    lines.extend(
        [
            "class CocoClient:",
            "    def __init__(self, base_url: str, api_key: Optional[str] = None) -> None:",
            "        self._base_url = base_url if base_url.endswith('/') else f\"{base_url}/\"",
            "        self._api_key = api_key",
            "",
            "    def _request(",
            "        self,",
            "        method: str,",
            "        path: str,",
            "        headers: Optional[dict[str, str]],",
            "        body: Optional[dict[str, Any]],",
            "        query: Optional[dict[str, Any]],",
            "        expect_json: bool,",
            "    ):",
            "        url = parse.urljoin(self._base_url, path.lstrip('/'))",
            "        if query:",
            "            filtered = {key: value for key, value in query.items() if value is not None}",
            "            if filtered:",
            "                encoded = parse.urlencode(filtered, doseq=True)",
            "                url = f\"{url}?{encoded}\"",
            "        request_headers: dict[str, str] = {}",
            "        if headers:",
            "            request_headers.update(headers)",
            "        if self._api_key:",
            "            request_headers[\"authorization\"] = f\"Bearer {self._api_key}\"",
            "        data: Optional[bytes] = None",
            "        if body is not None:",
            "            data = json.dumps(body).encode(\"utf-8\")",
            "            request_headers.setdefault(\"content-type\", \"application/json\")",
            "        req = request.Request(url, data=data, headers=request_headers, method=method)",
            "        try:",
            "            with request.urlopen(req) as resp:",
            "                payload = resp.read()",
            "        except error.HTTPError as exc:",
            "            payload = exc.read().decode(\"utf-8\", \"ignore\")",
            "            raise RuntimeError(f\"Request failed: {exc.code} {payload}\") from exc",
            "        if not expect_json:",
            "            return payload",
            "        if not payload:",
            "            return None",
            "        return json.loads(payload.decode(\"utf-8\"))",
            "",
        ]
    )
    lines.extend(methods)
    return "\n".join(lines).rstrip() + "\n"


def main() -> None:
    repo_root = Path(__file__).resolve().parents[1]
    openapi_path = repo_root / "openapi.json"
    sdk_dir = repo_root / "sdk_py" / "coco_sdk"
    sdk_dir.mkdir(parents=True, exist_ok=True)
    openapi = json.loads(openapi_path.read_text())

    types_path = sdk_dir / "types.py"
    client_path = sdk_dir / "client.py"
    init_path = sdk_dir / "__init__.py"

    types_path.write_text(generate_types(openapi))
    client_path.write_text(generate_client(openapi))
    init_path.write_text("from .client import CocoClient\nfrom .types import *\n")

    print(f"Wrote {types_path}")
    print(f"Wrote {client_path}")
    print(f"Wrote {init_path}")


if __name__ == "__main__":
    main()
