#!/usr/bin/env python3
import json
from pathlib import Path
from typing import Dict, List, Optional, Tuple


def ref_name(ref: str) -> str:
    return ref.rsplit("/", 1)[-1]


def schema_to_ts(schema: Dict) -> str:
    if "$ref" in schema:
        return ref_name(schema["$ref"])
    if "allOf" in schema:
        parts = [schema_to_ts(item) for item in schema["allOf"]]
        return " & ".join(parts) if parts else "unknown"
    if "enum" in schema:
        return " | ".join(json.dumps(value) for value in schema["enum"])
    schema_type = schema.get("type")
    if schema_type == "array":
        items = schema_to_ts(schema.get("items", {}))
        return f"{items}[]"
    if schema_type == "object" or "properties" in schema:
        return "Record<string, unknown>"
    if schema_type == "string":
        return "string"
    if schema_type in ("integer", "number"):
        return "number"
    if schema_type == "boolean":
        return "boolean"
    return "unknown"


def render_interface(name: str, schema: Dict) -> str:
    props = schema.get("properties", {})
    required = set(schema.get("required", []))
    lines = [f"export interface {name} {{"]
    for prop_name in sorted(props.keys()):
        prop_schema = props[prop_name]
        ts_type = schema_to_ts(prop_schema)
        if prop_schema.get("nullable"):
            ts_type = f"{ts_type} | null"
        optional = "" if prop_name in required else "?"
        desc = prop_schema.get("description")
        if desc:
            lines.append(f"  /** {desc} */")
        lines.append(f"  {prop_name}{optional}: {ts_type};")
    if not props:
        lines.append("  [key: string]: unknown;")
    lines.append("}")
    return "\n".join(lines)


def generate_types(openapi: Dict) -> str:
    schemas = openapi.get("components", {}).get("schemas", {})
    lines = [
        "/* This file is generated by scripts/generate-ts-sdk.py. */",
        "/* Do not edit by hand. */",
        "",
    ]
    for name in sorted(schemas.keys()):
        schema = schemas[name]
        desc = schema.get("description")
        if desc:
            lines.append(f"/** {desc} */")
        if "enum" in schema:
            lines.append(f"export type {name} = {schema_to_ts(schema)};")
        elif schema.get("type") == "object" or "properties" in schema:
            lines.append(render_interface(name, schema))
        else:
            lines.append(f"export type {name} = {schema_to_ts(schema)};")
        lines.append("")
    return "\n".join(lines).rstrip() + "\n"


def to_camel(name: str) -> str:
    parts = [p for p in name.replace("-", "_").split("_") if p]
    if not parts:
        return name
    return parts[0] + "".join(part.capitalize() for part in parts[1:])


def to_pascal(name: str) -> str:
    camel = to_camel(name)
    if not camel:
        return camel
    return camel[0].upper() + camel[1:]


def build_path(path: str, params: List[Dict]) -> Tuple[str, List[str]]:
    path_params = [p for p in params if p.get("in") == "path"]
    args = []
    rendered = path
    for param in path_params:
        name = param["name"]
        args.append(f"{name}: string")
        rendered = rendered.replace("{" + name + "}", f"${{{name}}}")
    return rendered, args


def header_params_type(op_id: str, params: List[Dict]) -> Tuple[str, Optional[str]]:
    header_params = [p for p in params if p.get("in") == "header"]
    if not header_params:
        return "", None
    type_name = f"{to_pascal(op_id)}Headers"
    lines = [f"export interface {type_name} {{"]
    for param in header_params:
        name = param["name"]
        required = param.get("required", False)
        optional = "" if required else "?"
        lines.append(f'  "{name}"{optional}: string;')
    lines.append("}")
    return "\n".join(lines), type_name


def query_params_type(
    op_id: str, params: List[Dict]
) -> Tuple[str, Optional[str], bool]:
    query_params = [p for p in params if p.get("in") == "query"]
    if not query_params:
        return "", None, False
    type_name = f"{to_pascal(op_id)}Query"
    lines = [f"export interface {type_name} {{"]
    required_any = False
    for param in query_params:
        name = param["name"]
        required = param.get("required", False)
        required_any = required_any or required
        optional = "" if required else "?"
        schema = param.get("schema", {})
        ts_type = schema_to_ts(schema)
        if schema.get("nullable"):
            ts_type = f"{ts_type} | null"
        lines.append(f'  "{name}"{optional}: {ts_type};')
    lines.append("}")
    return "\n".join(lines), type_name, required_any


def response_type(op: Dict) -> Tuple[str, bool]:
    responses = op.get("responses", {})
    ok = responses.get("200", {})
    content = ok.get("content", {})
    if "application/json" in content:
        schema = content["application/json"].get("schema", {})
        return schema_to_ts(schema), True
    return "Response", False


def request_type(op: Dict) -> Optional[str]:
    body = op.get("requestBody", {})
    content = body.get("content", {})
    if "application/json" in content:
        schema = content["application/json"].get("schema", {})
        return schema_to_ts(schema)
    return None


def generate_client(openapi: Dict) -> str:
    paths = openapi.get("paths", {})
    header_types: List[str] = []
    query_types: List[str] = []
    methods: List[str] = []
    for path, path_item in paths.items():
        for method, op in path_item.items():
            op_id = op.get("operationId") or f"{method}_{path}"
            params = op.get("parameters", [])
            rendered_path, path_args = build_path(path, params)
            header_decl, header_type = header_params_type(op_id, params)
            if header_decl:
                header_types.append(header_decl)
            query_decl, query_type, _query_required = query_params_type(op_id, params)
            if query_decl:
                query_types.append(query_decl)
            req_type = request_type(op)
            res_type, json_response = response_type(op)
            func_name = to_camel(op_id)
            args = []
            args.extend(path_args)
            if query_type:
                args.append(f"query: {query_type}")
            if req_type:
                args.append(f"request: {req_type}")
            if header_type:
                args.append(f"headers: {header_type}")
            arg_list = ", ".join(args)
            init_lines = [
                "const url = new URL(`%s`, this.baseUrl);" % rendered_path,
            ]
            if query_type:
                init_lines.append("if (query) {")
                init_lines.append("  const entries = query as Record<string, unknown>;");
                init_lines.append(
                    "  for (const [key, value] of Object.entries(entries)) {"
                )
                init_lines.append(
                    "    if (value !== undefined && value !== null) {"
                )
                init_lines.append("      url.searchParams.set(key, String(value));")
                init_lines.append("    }")
                init_lines.append("  }")
                init_lines.append("}")
            if req_type:
                init_lines.append("const body = JSON.stringify(request);")
            if header_type:
                init_lines.append("const merged = { ...headers };")
            else:
                init_lines.append("const merged: Record<string, string> = {};")
            if req_type:
                init_lines.append('merged["content-type"] = "application/json";')
            init_lines.append(
                'const response = await fetch(url.toString(), this.withAuth({ method: "%s", headers: merged%s }));'
                % (method.upper(), ", body" if req_type else "")
            )
            init_lines.append("if (!response.ok) {")
            init_lines.append("  const text = await response.text();")
            init_lines.append(
                "  throw new Error(`Request failed: ${response.status} ${text}`);"
            )
            init_lines.append("}")
            if json_response:
                init_lines.append("return (await response.json()) as %s;" % res_type)
            else:
                init_lines.append("return response;")
            return_type = res_type if json_response else "Response"
            method_lines = [
                f"  async {func_name}({arg_list}): Promise<{return_type}> {{"
            ]
            method_lines.extend(f"    {line}" for line in init_lines)
            method_lines.append("  }")
            methods.append("\n".join(method_lines))
    lines = [
        "/* This file is generated by scripts/generate-ts-sdk.py. */",
        "/* Do not edit by hand. */",
        "",
        'import { ' + ", ".join(sorted(openapi.get("components", {}).get("schemas", {}).keys())) + ' } from "./types";',
        "",
        "export interface CocoClientConfig {",
        "  baseUrl: string;",
        "  apiKey?: string;",
        "}",
        "",
    ]
    if header_types:
        lines.extend(header_types)
        lines.append("")
    if query_types:
        lines.extend(query_types)
        lines.append("")
    lines.extend(
        [
            "export class CocoClient {",
            "  private readonly baseUrl: string;",
            "  private readonly apiKey?: string;",
            "",
            "  constructor(config: CocoClientConfig) {",
            "    this.baseUrl = config.baseUrl.endsWith('/') ? config.baseUrl : `${config.baseUrl}/`;",
            "    this.apiKey = config.apiKey;",
            "  }",
            "",
            "  private withAuth(init: RequestInit): RequestInit {",
            "    if (!this.apiKey) {",
            "      return init;",
            "    }",
            "    const headers = new Headers(init.headers ?? {});",
            "    headers.set('authorization', `Bearer ${this.apiKey}`);",
            "    return { ...init, headers };",
            "  }",
            "",
        ]
    )
    lines.extend(methods)
    lines.append("}")
    lines.append("")
    return "\n".join(lines)


def main() -> None:
    repo_root = Path(__file__).resolve().parents[1]
    openapi_path = repo_root / "openapi.json"
    sdk_dir = repo_root / "sdk"
    sdk_dir.mkdir(exist_ok=True)
    openapi = json.loads(openapi_path.read_text())

    types_path = sdk_dir / "types.ts"
    client_path = sdk_dir / "client.ts"
    index_path = sdk_dir / "index.ts"

    types_path.write_text(generate_types(openapi))
    client_path.write_text(generate_client(openapi))
    index_path.write_text(
        "export * from './types';\nexport * from './client';\n"
    )

    print(f"Wrote {types_path}")
    print(f"Wrote {client_path}")
    print(f"Wrote {index_path}")


if __name__ == "__main__":
    main()
