# This file is generated by scripts/generate-py-sdk.py.
# Do not edit by hand.

from typing import Any, Literal, Optional, TypedDict

try:
    from typing import NotRequired
except ImportError:  # pragma: no cover
    class _NotRequired:
        def __class_getitem__(cls, item):
            return item
    NotRequired = _NotRequired

OpenApiDocument = dict[str, Any]

class ActivateConfigRequest(TypedDict):
    config_id: str
    org_id: str
    project_id: str

class ActivateConfigResponse(TypedDict):
    active_config_id: str

"""A chunk extracted from a document."""
class Chunk(TypedDict):
    content: str
    doc_id: str
    embedding: NotRequired[Optional[list[float]]]
    id: str
    quality_score: NotRequired[Optional[float]]
    span: TextSpan
    verified: NotRequired[Optional[bool]]

"""High-level error categories for CoCo.

Adding new variants is a breaking change for the public API."""
CocoErrorKind = Literal["system", "user", "network", "storage", "compute"]

"""Serializable error response used by API layers."""
class ErrorResponse(TypedDict):
    kind: CocoErrorKind
    message: str

class HealthResponse(TypedDict):
    queue: QueueStatusResponse
    service: str
    status: str
    vector_backend: VectorBackendStatus
    version: str
    worker: WorkerStatusResponse

"""HNSW index parameters."""
class HnswParams(TypedDict):
    ef_construction: NotRequired[Optional[int]]
    m: NotRequired[Optional[int]]

class IndexRequest(TypedDict):
    indexing_config_id: NotRequired[Optional[str]]

class IndexResponse(TypedDict):
    status: str

class IndexingConfigResponse(TypedDict):
    config: IndexingConfig

class IngestBatchRequest(TypedDict):
    activate: NotRequired[bool]
    documents: list[IngestDocument]
    indexing_config_id: NotRequired[Optional[str]]

class IngestBatchResponse(TypedDict):
    job_id: str

class IngestChunk(TypedDict):
    chunk_id: str
    content: str
    embedding: list[float]
    end: int
    quality_score: NotRequired[Optional[float]]
    start: int
    verified: NotRequired[Optional[bool]]

class IngestDocument(TypedDict):
    chunks: list[IngestChunk]
    content_hash: NotRequired[Optional[str]]
    doc_id: str
    quality_score: NotRequired[Optional[float]]
    source_ref: str
    title: NotRequired[Optional[str]]
    verified: NotRequired[Optional[bool]]

"""IVF-PQ index parameters."""
class IvfPqParams(TypedDict):
    max_iterations: NotRequired[Optional[int]]
    num_partitions: NotRequired[Optional[int]]
    num_sub_vectors: NotRequired[Optional[int]]
    sample_rate: NotRequired[Optional[int]]

class JobStatusResponse(TypedDict):
    attempts: int
    created_at: str
    error: NotRequired[Optional[str]]
    job_id: str
    status: str
    updated_at: str
    version_id: NotRequired[Optional[str]]

class ListConfigsQuery(TypedDict):
    org_id: str
    project_id: NotRequired[Optional[str]]

class ListConfigsResponse(TypedDict):
    active_config_id: NotRequired[Optional[str]]
    configs: list[IndexingConfig]

class MemoQueryRequest(TypedDict):
    intent: PublicSearchIntent
    session_token: str

class MemoQueryResponseEnvelope(TypedDict):
    data: QueryResponse
    meta: ResponseMeta

class PruneRequest(TypedDict):
    keep: NotRequired[Optional[int]]
    org_id: str
    project_id: str

class PruneResponse(TypedDict):
    removed: int

"""Filter constraint accepted by the public server API."""
class PublicFilter(TypedDict):
    field: str
    op: PublicFilterOp
    value: str

"""Filter operator documented for the public server API."""
PublicFilterOp = Literal["eq", "contains"]

"""Search intent describing how retrieval should run."""
class PublicSearchIntent(TypedDict):
    filters: list[PublicFilter]
    hybrid_alpha: float
    indexing_config_id: NotRequired[Optional[str]]
    query_embedding: NotRequired[Optional[list[float]]]
    query_text: NotRequired[Optional[str]]
    reranker: NotRequired[Optional[coco_protocol.RerankerConfig]]
    retrieval_mode: coco_protocol.RetrievalMode
    top_k: int

class QueryRequest(TypedDict):
    indexing_config: NotRequired[Optional[IndexingConfig]]
    indexing_config_id: NotRequired[Optional[str]]
    intent: PublicSearchIntent
    retrieval_config: NotRequired[Optional[RetrievalConfig]]

class QueryResponse(TypedDict):
    results: list[SearchHit]

class QueryResponseEnvelope(TypedDict):
    data: QueryResponse
    meta: ResponseMeta

class QueueStatusResponse(TypedDict):
    detail: NotRequired[Optional[str]]
    mode: str
    status: str

class RegisterProjectRequest(TypedDict):
    name: str
    org_id: str
    org_name: NotRequired[Optional[str]]
    platform: NotRequired[Optional[str]]
    project_id: NotRequired[Optional[str]]
    source_ref: str

class RegisterProjectResponse(TypedDict):
    active_config_id: str
    active_version_id: NotRequired[Optional[str]]
    name: str
    org_id: str
    project_id: str

"""Reranker configuration for post-retrieval scoring."""
class RerankerConfig(TypedDict):
    model_name: str
    rerank_top_n: int

"""Response metadata for request-level status."""
class ResponseMeta(TypedDict):
    status: ResponseStatus

"""Response freshness indicator."""
ResponseStatus = Literal["fresh", "stale"]

"""Retrieval mode for query execution."""
RetrievalMode = Literal["vector", "fts", "hybrid"]

"""A search hit with metadata and chunk payload."""
class SearchHit(TypedDict):
    chunk: Chunk
    meta: SearchHitMeta

"""Metadata associated with a search hit."""
class SearchHitMeta(TypedDict):
    quality: NotRequired[Optional[float]]
    score: float
    verified: NotRequired[Optional[bool]]

"""A span inside a document, expressed as byte offsets."""
class TextSpan(TypedDict):
    end: int
    start: int

class UpsertConfigRequest(TypedDict):
    config: IndexingConfig
    org_id: str

"""Supported vector backend types."""
VectorBackendKind = Literal["pg_vector", "qdrant"]

class VectorBackendStatus(TypedDict):
    detail: NotRequired[Optional[str]]
    kind: VectorBackendKind
    status: str
    version: NotRequired[Optional[str]]

"""Backend-specific index parameter overrides."""
class VectorIndexParams(TypedDict):
    hnsw: NotRequired[Optional[HnswParams]]
    ivf_pq: NotRequired[Optional[IvfPqParams]]

"""Supported vector similarity metrics."""
VectorMetric = Literal["cosine", "dot", "l2"]

class WorkerStatusResponse(TypedDict):
    status: str
    updated_at: NotRequired[Optional[str]]
    version: str
